{"ast":null,"code":"'use strict';\n\nconst {\n  getResponseData,\n  buildKey,\n  addMockDispatch\n} = require('./mock-utils');\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = require('./mock-symbols');\nconst {\n  InvalidArgumentError\n} = require('../core/errors');\nconst {\n  buildURL\n} = require('../core/util');\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor(mockDispatch) {\n    this[kMockDispatch] = mockDispatch;\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay(waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0');\n    }\n    this[kMockDispatch].delay = waitInMs;\n    return this;\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist() {\n    this[kMockDispatch].persist = true;\n    return this;\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times(repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0');\n    }\n    this[kMockDispatch].times = repeatTimes;\n    return this;\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor(opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object');\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined');\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET';\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = buildURL(opts.path, opts.query);\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://');\n        opts.path = parsedURL.pathname + parsedURL.search;\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase();\n    }\n    this[kDispatchKey] = buildKey(opts);\n    this[kDispatches] = mockDispatches;\n    this[kDefaultHeaders] = {};\n    this[kDefaultTrailers] = {};\n    this[kContentLength] = false;\n  }\n  createMockScopeDispatchData(statusCode, data) {\n    let responseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const responseData = getResponseData(data);\n    const contentLength = this[kContentLength] ? {\n      'content-length': responseData.length\n    } : {};\n    const headers = {\n      ...this[kDefaultHeaders],\n      ...contentLength,\n      ...responseOptions.headers\n    };\n    const trailers = {\n      ...this[kDefaultTrailers],\n      ...responseOptions.trailers\n    };\n    return {\n      statusCode,\n      data,\n      headers,\n      trailers\n    };\n  }\n  validateReplyParameters(statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined');\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined');\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object');\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply(replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = opts => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts);\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object');\n        }\n        const {\n          statusCode,\n          data = '',\n          responseOptions = {}\n        } = resolvedData;\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        };\n      };\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);\n      return new MockScope(newMockDispatch);\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const [statusCode, data = '', responseOptions = {}] = [...arguments];\n    this.validateReplyParameters(statusCode, data, responseOptions);\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);\n    return new MockScope(newMockDispatch);\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError(error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined');\n    }\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {\n      error\n    });\n    return new MockScope(newMockDispatch);\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders(headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined');\n    }\n    this[kDefaultHeaders] = headers;\n    return this;\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers(trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined');\n    }\n    this[kDefaultTrailers] = trailers;\n    return this;\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength() {\n    this[kContentLength] = true;\n    return this;\n  }\n}\nmodule.exports.MockInterceptor = MockInterceptor;\nmodule.exports.MockScope = MockScope;","map":{"version":3,"names":["getResponseData","buildKey","addMockDispatch","require","kDispatches","kDispatchKey","kDefaultHeaders","kDefaultTrailers","kContentLength","kMockDispatch","InvalidArgumentError","buildURL","MockScope","constructor","mockDispatch","delay","waitInMs","Number","isInteger","persist","times","repeatTimes","MockInterceptor","opts","mockDispatches","path","method","query","parsedURL","URL","pathname","search","toUpperCase","createMockScopeDispatchData","statusCode","data","responseOptions","arguments","length","undefined","responseData","contentLength","headers","trailers","validateReplyParameters","reply","replyData","wrappedDefaultsCallback","resolvedData","newMockDispatch","dispatchData","replyWithError","error","defaultReplyHeaders","defaultReplyTrailers","replyContentLength","module","exports"],"sources":["/Users/aluabajzanova/Desktop/skylineÂ /node_modules/undici/lib/mock/mock-interceptor.js"],"sourcesContent":["'use strict'\n\nconst { getResponseData, buildKey, addMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = require('./mock-symbols')\nconst { InvalidArgumentError } = require('../core/errors')\nconst { buildURL } = require('../core/util')\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = buildURL(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined')\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const { statusCode, data = '', responseOptions = {} } = resolvedData\n        this.validateReplyParameters(statusCode, data, responseOptions)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const [statusCode, data = '', responseOptions = {}] = [...arguments]\n    this.validateReplyParameters(statusCode, data, responseOptions)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA,eAAe;EAAEC,QAAQ;EAAEC;AAAgB,CAAC,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC9E,MAAM;EACJC,WAAW;EACXC,YAAY;EACZC,eAAe;EACfC,gBAAgB;EAChBC,cAAc;EACdC;AACF,CAAC,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AAC7B,MAAM;EAAEO;AAAqB,CAAC,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAC1D,MAAM;EAAEQ;AAAS,CAAC,GAAGR,OAAO,CAAC,cAAc,CAAC;;AAE5C;AACA;AACA;AACA,MAAMS,SAAS,CAAC;EACdC,WAAWA,CAAEC,YAAY,EAAE;IACzB,IAAI,CAACL,aAAa,CAAC,GAAGK,YAAY;EACpC;;EAEA;AACF;AACA;EACEC,KAAKA,CAAEC,QAAQ,EAAE;IACf,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAI,CAACC,MAAM,CAACC,SAAS,CAACF,QAAQ,CAAC,IAAIA,QAAQ,IAAI,CAAC,EAAE;MAChF,MAAM,IAAIN,oBAAoB,CAAC,sCAAsC,CAAC;IACxE;IAEA,IAAI,CAACD,aAAa,CAAC,CAACM,KAAK,GAAGC,QAAQ;IACpC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEG,OAAOA,CAAA,EAAI;IACT,IAAI,CAACV,aAAa,CAAC,CAACU,OAAO,GAAG,IAAI;IAClC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEC,KAAKA,CAAEC,WAAW,EAAE;IAClB,IAAI,OAAOA,WAAW,KAAK,QAAQ,IAAI,CAACJ,MAAM,CAACC,SAAS,CAACG,WAAW,CAAC,IAAIA,WAAW,IAAI,CAAC,EAAE;MACzF,MAAM,IAAIX,oBAAoB,CAAC,yCAAyC,CAAC;IAC3E;IAEA,IAAI,CAACD,aAAa,CAAC,CAACW,KAAK,GAAGC,WAAW;IACvC,OAAO,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA,MAAMC,eAAe,CAAC;EACpBT,WAAWA,CAAEU,IAAI,EAAEC,cAAc,EAAE;IACjC,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;MAC5B,MAAM,IAAIb,oBAAoB,CAAC,wBAAwB,CAAC;IAC1D;IACA,IAAI,OAAOa,IAAI,CAACE,IAAI,KAAK,WAAW,EAAE;MACpC,MAAM,IAAIf,oBAAoB,CAAC,2BAA2B,CAAC;IAC7D;IACA,IAAI,OAAOa,IAAI,CAACG,MAAM,KAAK,WAAW,EAAE;MACtCH,IAAI,CAACG,MAAM,GAAG,KAAK;IACrB;IACA;IACA;IACA;IACA,IAAI,OAAOH,IAAI,CAACE,IAAI,KAAK,QAAQ,EAAE;MACjC,IAAIF,IAAI,CAACI,KAAK,EAAE;QACdJ,IAAI,CAACE,IAAI,GAAGd,QAAQ,CAACY,IAAI,CAACE,IAAI,EAAEF,IAAI,CAACI,KAAK,CAAC;MAC7C,CAAC,MAAM;QACL;QACA,MAAMC,SAAS,GAAG,IAAIC,GAAG,CAACN,IAAI,CAACE,IAAI,EAAE,SAAS,CAAC;QAC/CF,IAAI,CAACE,IAAI,GAAGG,SAAS,CAACE,QAAQ,GAAGF,SAAS,CAACG,MAAM;MACnD;IACF;IACA,IAAI,OAAOR,IAAI,CAACG,MAAM,KAAK,QAAQ,EAAE;MACnCH,IAAI,CAACG,MAAM,GAAGH,IAAI,CAACG,MAAM,CAACM,WAAW,CAAC,CAAC;IACzC;IAEA,IAAI,CAAC3B,YAAY,CAAC,GAAGJ,QAAQ,CAACsB,IAAI,CAAC;IACnC,IAAI,CAACnB,WAAW,CAAC,GAAGoB,cAAc;IAClC,IAAI,CAAClB,eAAe,CAAC,GAAG,CAAC,CAAC;IAC1B,IAAI,CAACC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IAC3B,IAAI,CAACC,cAAc,CAAC,GAAG,KAAK;EAC9B;EAEAyB,2BAA2BA,CAAEC,UAAU,EAAEC,IAAI,EAAwB;IAAA,IAAtBC,eAAe,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACjE,MAAMG,YAAY,GAAGxC,eAAe,CAACmC,IAAI,CAAC;IAC1C,MAAMM,aAAa,GAAG,IAAI,CAACjC,cAAc,CAAC,GAAG;MAAE,gBAAgB,EAAEgC,YAAY,CAACF;IAAO,CAAC,GAAG,CAAC,CAAC;IAC3F,MAAMI,OAAO,GAAG;MAAE,GAAG,IAAI,CAACpC,eAAe,CAAC;MAAE,GAAGmC,aAAa;MAAE,GAAGL,eAAe,CAACM;IAAQ,CAAC;IAC1F,MAAMC,QAAQ,GAAG;MAAE,GAAG,IAAI,CAACpC,gBAAgB,CAAC;MAAE,GAAG6B,eAAe,CAACO;IAAS,CAAC;IAE3E,OAAO;MAAET,UAAU;MAAEC,IAAI;MAAEO,OAAO;MAAEC;IAAS,CAAC;EAChD;EAEAC,uBAAuBA,CAAEV,UAAU,EAAEC,IAAI,EAAEC,eAAe,EAAE;IAC1D,IAAI,OAAOF,UAAU,KAAK,WAAW,EAAE;MACrC,MAAM,IAAIxB,oBAAoB,CAAC,4BAA4B,CAAC;IAC9D;IACA,IAAI,OAAOyB,IAAI,KAAK,WAAW,EAAE;MAC/B,MAAM,IAAIzB,oBAAoB,CAAC,sBAAsB,CAAC;IACxD;IACA,IAAI,OAAO0B,eAAe,KAAK,QAAQ,EAAE;MACvC,MAAM,IAAI1B,oBAAoB,CAAC,mCAAmC,CAAC;IACrE;EACF;;EAEA;AACF;AACA;EACEmC,KAAKA,CAAEC,SAAS,EAAE;IAChB;IACA;IACA,IAAI,OAAOA,SAAS,KAAK,UAAU,EAAE;MACnC;MACA;MACA;MACA,MAAMC,uBAAuB,GAAIxB,IAAI,IAAK;QACxC;QACA,MAAMyB,YAAY,GAAGF,SAAS,CAACvB,IAAI,CAAC;;QAEpC;QACA,IAAI,OAAOyB,YAAY,KAAK,QAAQ,EAAE;UACpC,MAAM,IAAItC,oBAAoB,CAAC,8CAA8C,CAAC;QAChF;QAEA,MAAM;UAAEwB,UAAU;UAAEC,IAAI,GAAG,EAAE;UAAEC,eAAe,GAAG,CAAC;QAAE,CAAC,GAAGY,YAAY;QACpE,IAAI,CAACJ,uBAAuB,CAACV,UAAU,EAAEC,IAAI,EAAEC,eAAe,CAAC;QAC/D;QACA;QACA,OAAO;UACL,GAAG,IAAI,CAACH,2BAA2B,CAACC,UAAU,EAAEC,IAAI,EAAEC,eAAe;QACvE,CAAC;MACH,CAAC;;MAED;MACA,MAAMa,eAAe,GAAG/C,eAAe,CAAC,IAAI,CAACE,WAAW,CAAC,EAAE,IAAI,CAACC,YAAY,CAAC,EAAE0C,uBAAuB,CAAC;MACvG,OAAO,IAAInC,SAAS,CAACqC,eAAe,CAAC;IACvC;;IAEA;IACA;IACA;IACA;IACA,MAAM,CAACf,UAAU,EAAEC,IAAI,GAAG,EAAE,EAAEC,eAAe,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGC,SAAS,CAAC;IACpE,IAAI,CAACO,uBAAuB,CAACV,UAAU,EAAEC,IAAI,EAAEC,eAAe,CAAC;;IAE/D;IACA,MAAMc,YAAY,GAAG,IAAI,CAACjB,2BAA2B,CAACC,UAAU,EAAEC,IAAI,EAAEC,eAAe,CAAC;IACxF,MAAMa,eAAe,GAAG/C,eAAe,CAAC,IAAI,CAACE,WAAW,CAAC,EAAE,IAAI,CAACC,YAAY,CAAC,EAAE6C,YAAY,CAAC;IAC5F,OAAO,IAAItC,SAAS,CAACqC,eAAe,CAAC;EACvC;;EAEA;AACF;AACA;EACEE,cAAcA,CAAEC,KAAK,EAAE;IACrB,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;MAChC,MAAM,IAAI1C,oBAAoB,CAAC,uBAAuB,CAAC;IACzD;IAEA,MAAMuC,eAAe,GAAG/C,eAAe,CAAC,IAAI,CAACE,WAAW,CAAC,EAAE,IAAI,CAACC,YAAY,CAAC,EAAE;MAAE+C;IAAM,CAAC,CAAC;IACzF,OAAO,IAAIxC,SAAS,CAACqC,eAAe,CAAC;EACvC;;EAEA;AACF;AACA;EACEI,mBAAmBA,CAAEX,OAAO,EAAE;IAC5B,IAAI,OAAOA,OAAO,KAAK,WAAW,EAAE;MAClC,MAAM,IAAIhC,oBAAoB,CAAC,yBAAyB,CAAC;IAC3D;IAEA,IAAI,CAACJ,eAAe,CAAC,GAAGoC,OAAO;IAC/B,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEY,oBAAoBA,CAAEX,QAAQ,EAAE;IAC9B,IAAI,OAAOA,QAAQ,KAAK,WAAW,EAAE;MACnC,MAAM,IAAIjC,oBAAoB,CAAC,0BAA0B,CAAC;IAC5D;IAEA,IAAI,CAACH,gBAAgB,CAAC,GAAGoC,QAAQ;IACjC,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEY,kBAAkBA,CAAA,EAAI;IACpB,IAAI,CAAC/C,cAAc,CAAC,GAAG,IAAI;IAC3B,OAAO,IAAI;EACb;AACF;AAEAgD,MAAM,CAACC,OAAO,CAACnC,eAAe,GAAGA,eAAe;AAChDkC,MAAM,CAACC,OAAO,CAAC7C,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}