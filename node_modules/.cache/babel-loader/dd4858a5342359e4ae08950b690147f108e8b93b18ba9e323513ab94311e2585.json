{"ast":null,"code":"'use strict';\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors');\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base');\nconst Pool = require('./pool');\nconst {\n  kUrl,\n  kInterceptors\n} = require('./core/symbols');\nconst {\n  parseOrigin\n} = require('./core/util');\nconst kFactory = Symbol('factory');\nconst kOptions = Symbol('options');\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');\nconst kCurrentWeight = Symbol('kCurrentWeight');\nconst kIndex = Symbol('kIndex');\nconst kWeight = Symbol('kWeight');\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer');\nconst kErrorPenalty = Symbol('kErrorPenalty');\nfunction getGreatestCommonDivisor(a, b) {\n  if (b === 0) return a;\n  return getGreatestCommonDivisor(b, a % b);\n}\nfunction defaultFactory(origin, opts) {\n  return new Pool(origin, opts);\n}\nclass BalancedPool extends PoolBase {\n  constructor() {\n    let upstreams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let {\n      factory = defaultFactory,\n      ...opts\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this[kOptions] = opts;\n    this[kIndex] = -1;\n    this[kCurrentWeight] = 0;\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams];\n    }\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];\n    this[kFactory] = factory;\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream);\n    }\n    this._updateBalancedPoolStats();\n  }\n  addUpstream(upstream) {\n    var _this = this;\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    if (this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true)) {\n      return this;\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));\n    this[kAddClient](pool);\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);\n    });\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);\n      this._updateBalancedPoolStats();\n    });\n    pool.on('disconnect', function () {\n      const err = arguments.length <= 2 ? undefined : arguments[2];\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - _this[kErrorPenalty]);\n        _this._updateBalancedPoolStats();\n      }\n    });\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer];\n    }\n    this._updateBalancedPoolStats();\n    return this;\n  }\n  _updateBalancedPoolStats() {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0);\n  }\n  removeUpstream(upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin;\n    const pool = this[kClients].find(pool => pool[kUrl].origin === upstreamOrigin && pool.closed !== true && pool.destroyed !== true);\n    if (pool) {\n      this[kRemoveClient](pool);\n    }\n    return this;\n  }\n  get upstreams() {\n    return this[kClients].filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true).map(p => p[kUrl].origin);\n  }\n  [kGetDispatcher]() {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError();\n    }\n    const dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);\n    if (!dispatcher) {\n      return;\n    }\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);\n    if (allClientsBusy) {\n      return;\n    }\n    let counter = 0;\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;\n      const pool = this[kClients][this[kIndex]];\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex];\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer];\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {\n        return pool;\n      }\n    }\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];\n    this[kIndex] = maxWeightIndex;\n    return this[kClients][maxWeightIndex];\n  }\n}\nmodule.exports = BalancedPool;","map":{"version":3,"names":["BalancedPoolMissingUpstreamError","InvalidArgumentError","require","PoolBase","kClients","kNeedDrain","kAddClient","kRemoveClient","kGetDispatcher","Pool","kUrl","kInterceptors","parseOrigin","kFactory","Symbol","kOptions","kGreatestCommonDivisor","kCurrentWeight","kIndex","kWeight","kMaxWeightPerServer","kErrorPenalty","getGreatestCommonDivisor","a","b","defaultFactory","origin","opts","BalancedPool","constructor","upstreams","arguments","length","undefined","factory","maxWeightPerServer","errorPenalty","Array","isArray","interceptors","upstream","addUpstream","_updateBalancedPoolStats","_this","upstreamOrigin","find","pool","closed","destroyed","Object","assign","on","Math","min","max","err","code","client","map","p","reduce","removeUpstream","filter","dispatcher","allClientsBusy","counter","maxWeightIndex","findIndex","module","exports"],"sources":["/Users/aluabajzanova/Desktop/skylineÂ /node_modules/undici/lib/balanced-pool.js"],"sourcesContent":["'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = require('./core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl, kInterceptors } = require('./core/symbols')\nconst { parseOrigin } = require('./core/util')\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\nfunction getGreatestCommonDivisor (a, b) {\n  if (b === 0) return a\n  return getGreatestCommonDivisor(b, a % b)\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}