{"ast":null,"code":"// @ts-check\n\n'use strict';\n\n/* global WebAssembly */\nconst assert = require('assert');\nconst net = require('net');\nconst util = require('./core/util');\nconst timers = require('./timers');\nconst Request = require('./core/request');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols');\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor(url) {\n    let {\n      interceptors,\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient,\n      localAddress,\n      maxResponseSize,\n      autoSelectFamily,\n      autoSelectFamilyAttemptTimeout\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address');\n    }\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number');\n    }\n    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n          autoSelectFamily,\n          autoSelectFamilyAttemptTimeout\n        } : undefined),\n        ...connect\n      });\n    }\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kLocalAddress] = localAddress != null ? localAddress : null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        resolve(null);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve();\n      };\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n      resume(this);\n    });\n  }\n}\nconst constants = require('./llhttp/constants');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp-wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd-wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp-wasm.js'), 'base64'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n    this.connection = '';\n    this.maxResponseSize = client[kMaxResponseSize];\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = 'Response does not match the HTTP/1.1 protocol (' + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ')';\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    timers.clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    resume(client);\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive ||\n    // Override llhttp value which does not allow keepAlive for HEAD.\n    request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive';\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    let pause;\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode,\n      maxResponseSize\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError());\n      return -1;\n    }\n    this.bytesRead += buf.length;\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    this.connection = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  this[kError] = err;\n  onError(this[kClient], err);\n}\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete();\n  }\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n  if (client.destroyed) {\n    assert(client[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());\n      return;\n    }\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n    client[kConnecting] = false;\n    assert(socket);\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n    client[kSocket] = socket;\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    if (client.destroyed) {\n      return;\n    }\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  resume(client);\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]();\n      client[kClosedResolve] = null;\n      return;\n    }\n    const socket = client[kSocket];\n    if (socket && !socket.destroyed) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!socket) {\n      connect(client);\n      return;\n    }\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data', /* istanbul ignore next */function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking,\n    reset\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (reset != null) {\n    socket[kReset] = reset;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (headers) {\n    header += headers;\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'latin1');\n    }\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    if (finished) {\n      return;\n    }\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    if (finished) {\n      return;\n    }\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    socket.cork();\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    socket.uncork();\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1');\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    resume(client);\n  }\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n}\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","timers","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","ResponseExceededMaxSizeError","ClientDestroyedError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kLocalAddress","kMaxResponseSize","FastBuffer","Buffer","Symbol","species","kClosedResolve","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","localAddress","maxResponseSize","autoSelectFamily","autoSelectFamilyAttemptTimeout","arguments","length","undefined","Number","isFinite","isInteger","isIP","timeout","nodeHasAutoSelectFamily","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","value","resume","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","err","requests","splice","i","errorRequest","callback","queueMicrotask","destroy","on","constants","EMPTY_BUF","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","currentBufferRef","byteOffset","onStatus","buffer","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","_ref","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","connection","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","slice","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","code","onError","host","protocol","idx","ip","substr","publish","connectParams","servername","connector","reject","error","emitDrain","sync","_resume","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","reset","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","_ref2","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","end","er","_ref3","size","arrayBuffer","_ref4","waitForDrain","_ref5","bytesWritten","module"],"sources":["/Users/aluabajzanova/Desktop/skyline /node_modules/undici/lib/client.js"],"sourcesContent":["// @ts-check\n\n'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst timers = require('./timers')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols')\nconst FastBuffer = Buffer[Symbol.species]\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\n/**\n * @type {import('../types/client').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../types/client').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        resolve(null)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp-wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd-wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp-wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete()\n  }\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', () => {}), new ClientDestroyedError())\n      return\n    }\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    client[kSocket] = socket\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket && !socket.destroyed) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      return\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'latin1')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}