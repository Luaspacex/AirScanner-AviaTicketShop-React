{"ast":null,"code":"'use strict';\n\nconst net = require('net');\nconst assert = require('assert');\nconst util = require('./util');\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\nlet tls; // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache;\nif (global.FinalizationRegistry) {\n  SessionCache = class WeakSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n      this._sessionRegistry = new global.FinalizationRegistry(key => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return;\n        }\n        const ref = this._sessionCache.get(key);\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key);\n        }\n      });\n    }\n    get(sessionKey) {\n      const ref = this._sessionCache.get(sessionKey);\n      return ref ? ref.deref() : null;\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      this._sessionCache.set(sessionKey, new WeakRef(session));\n      this._sessionRegistry.register(session, sessionKey);\n    }\n  };\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor(maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions;\n      this._sessionCache = new Map();\n    }\n    get(sessionKey) {\n      return this._sessionCache.get(sessionKey);\n    }\n    set(sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return;\n      }\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const {\n          value: oldestKey\n        } = this._sessionCache.keys().next();\n        this._sessionCache.delete(oldestKey);\n      }\n      this._sessionCache.set(sessionKey, session);\n    }\n  };\n}\nfunction buildConnector(_ref) {\n  let {\n    maxCachedSessions,\n    socketPath,\n    timeout,\n    ...opts\n  } = _ref;\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);\n  timeout = timeout == null ? 10e3 : timeout;\n  return function connect(_ref2, callback) {\n    let {\n      hostname,\n      host,\n      protocol,\n      port,\n      servername,\n      localAddress,\n      httpSocket\n    } = _ref2;\n    let socket;\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        socket: httpSocket,\n        // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // TODO (fix): Can a session become invalid once established? Don't think so?\n        sessionCache.set(sessionKey, session);\n      });\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update');\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;\n      socket.setKeepAlive(true, keepAliveInitialDelay);\n    }\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      cancelTimeout();\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\nfunction setupTimeout(onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {};\n  }\n  let s1 = null;\n  let s2 = null;\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout());\n      } else {\n        onConnectTimeout();\n      }\n    });\n  }, timeout);\n  return () => {\n    clearTimeout(timeoutId);\n    clearImmediate(s1);\n    clearImmediate(s2);\n  };\n}\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","SessionCache","global","FinalizationRegistry","WeakSessionCache","constructor","maxCachedSessions","_maxCachedSessions","_sessionCache","Map","_sessionRegistry","key","size","ref","get","undefined","deref","delete","sessionKey","set","session","WeakRef","register","SimpleSessionCache","value","oldestKey","keys","next","buildConnector","_ref","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","connect","_ref2","callback","hostname","host","protocol","port","servername","localAddress","httpSocket","socket","getServerName","highWaterMark","on","keepAlive","keepAliveInitialDelay","setKeepAlive","cancelTimeout","setupTimeout","onConnectTimeout","setNoDelay","once","cb","err","s1","s2","timeoutId","setTimeout","setImmediate","process","platform","clearTimeout","clearImmediate","destroy","module","exports"],"sources":["/Users/aluabajzanova/Desktop/skylineÂ /node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\nif (global.FinalizationRegistry) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        socket: httpSocket, // upgrade socket connection\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout)\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        cancelTimeout()\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction setupTimeout (onConnectTimeout, timeout) {\n  if (!timeout) {\n    return () => {}\n  }\n\n  let s1 = null\n  let s2 = null\n  const timeoutId = setTimeout(() => {\n    // setImmediate is added to make sure that we priotorise socket error events over timeouts\n    s1 = setImmediate(() => {\n      if (process.platform === 'win32') {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n        s2 = setImmediate(() => onConnectTimeout())\n      } else {\n        onConnectTimeout()\n      }\n    })\n  }, timeout)\n  return () => {\n    clearTimeout(timeoutId)\n    clearImmediate(s1)\n    clearImmediate(s2)\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAME,IAAI,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC9B,MAAM;EAAEG,oBAAoB;EAAEC;AAAoB,CAAC,GAAGJ,OAAO,CAAC,UAAU,CAAC;AAEzE,IAAIK,GAAG,EAAC;;AAER;AACA;AACA;AACA;;AAEA,IAAIC,YAAY;AAChB,IAAIC,MAAM,CAACC,oBAAoB,EAAE;EAC/BF,YAAY,GAAG,MAAMG,gBAAgB,CAAC;IACpCC,WAAWA,CAAEC,iBAAiB,EAAE;MAC9B,IAAI,CAACC,kBAAkB,GAAGD,iBAAiB;MAC3C,IAAI,CAACE,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;MAC9B,IAAI,CAACC,gBAAgB,GAAG,IAAIR,MAAM,CAACC,oBAAoB,CAAEQ,GAAG,IAAK;QAC/D,IAAI,IAAI,CAACH,aAAa,CAACI,IAAI,GAAG,IAAI,CAACL,kBAAkB,EAAE;UACrD;QACF;QAEA,MAAMM,GAAG,GAAG,IAAI,CAACL,aAAa,CAACM,GAAG,CAACH,GAAG,CAAC;QACvC,IAAIE,GAAG,KAAKE,SAAS,IAAIF,GAAG,CAACG,KAAK,CAAC,CAAC,KAAKD,SAAS,EAAE;UAClD,IAAI,CAACP,aAAa,CAACS,MAAM,CAACN,GAAG,CAAC;QAChC;MACF,CAAC,CAAC;IACJ;IAEAG,GAAGA,CAAEI,UAAU,EAAE;MACf,MAAML,GAAG,GAAG,IAAI,CAACL,aAAa,CAACM,GAAG,CAACI,UAAU,CAAC;MAC9C,OAAOL,GAAG,GAAGA,GAAG,CAACG,KAAK,CAAC,CAAC,GAAG,IAAI;IACjC;IAEAG,GAAGA,CAAED,UAAU,EAAEE,OAAO,EAAE;MACxB,IAAI,IAAI,CAACb,kBAAkB,KAAK,CAAC,EAAE;QACjC;MACF;MAEA,IAAI,CAACC,aAAa,CAACW,GAAG,CAACD,UAAU,EAAE,IAAIG,OAAO,CAACD,OAAO,CAAC,CAAC;MACxD,IAAI,CAACV,gBAAgB,CAACY,QAAQ,CAACF,OAAO,EAAEF,UAAU,CAAC;IACrD;EACF,CAAC;AACH,CAAC,MAAM;EACLjB,YAAY,GAAG,MAAMsB,kBAAkB,CAAC;IACtClB,WAAWA,CAAEC,iBAAiB,EAAE;MAC9B,IAAI,CAACC,kBAAkB,GAAGD,iBAAiB;MAC3C,IAAI,CAACE,aAAa,GAAG,IAAIC,GAAG,CAAC,CAAC;IAChC;IAEAK,GAAGA,CAAEI,UAAU,EAAE;MACf,OAAO,IAAI,CAACV,aAAa,CAACM,GAAG,CAACI,UAAU,CAAC;IAC3C;IAEAC,GAAGA,CAAED,UAAU,EAAEE,OAAO,EAAE;MACxB,IAAI,IAAI,CAACb,kBAAkB,KAAK,CAAC,EAAE;QACjC;MACF;MAEA,IAAI,IAAI,CAACC,aAAa,CAACI,IAAI,IAAI,IAAI,CAACL,kBAAkB,EAAE;QACtD;QACA,MAAM;UAAEiB,KAAK,EAAEC;QAAU,CAAC,GAAG,IAAI,CAACjB,aAAa,CAACkB,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC;QAC7D,IAAI,CAACnB,aAAa,CAACS,MAAM,CAACQ,SAAS,CAAC;MACtC;MAEA,IAAI,CAACjB,aAAa,CAACW,GAAG,CAACD,UAAU,EAAEE,OAAO,CAAC;IAC7C;EACF,CAAC;AACH;AAEA,SAASQ,cAAcA,CAAAC,IAAA,EAAuD;EAAA,IAArD;IAAEvB,iBAAiB;IAAEwB,UAAU;IAAEC,OAAO;IAAE,GAAGC;EAAK,CAAC,GAAAH,IAAA;EAC1E,IAAIvB,iBAAiB,IAAI,IAAI,KAAK,CAAC2B,MAAM,CAACC,SAAS,CAAC5B,iBAAiB,CAAC,IAAIA,iBAAiB,GAAG,CAAC,CAAC,EAAE;IAChG,MAAM,IAAIR,oBAAoB,CAAC,sDAAsD,CAAC;EACxF;EAEA,MAAMqC,OAAO,GAAG;IAAEC,IAAI,EAAEN,UAAU;IAAE,GAAGE;EAAK,CAAC;EAC7C,MAAMK,YAAY,GAAG,IAAIpC,YAAY,CAACK,iBAAiB,IAAI,IAAI,GAAG,GAAG,GAAGA,iBAAiB,CAAC;EAC1FyB,OAAO,GAAGA,OAAO,IAAI,IAAI,GAAG,IAAI,GAAGA,OAAO;EAE1C,OAAO,SAASO,OAAOA,CAAAC,KAAA,EAA4EC,QAAQ,EAAE;IAAA,IAApF;MAAEC,QAAQ;MAAEC,IAAI;MAAEC,QAAQ;MAAEC,IAAI;MAAEC,UAAU;MAAEC,YAAY;MAAEC;IAAW,CAAC,GAAAR,KAAA;IAC/F,IAAIS,MAAM;IACV,IAAIL,QAAQ,KAAK,QAAQ,EAAE;MACzB,IAAI,CAAC3C,GAAG,EAAE;QACRA,GAAG,GAAGL,OAAO,CAAC,KAAK,CAAC;MACtB;MACAkD,UAAU,GAAGA,UAAU,IAAIV,OAAO,CAACU,UAAU,IAAIhD,IAAI,CAACoD,aAAa,CAACP,IAAI,CAAC,IAAI,IAAI;MAEjF,MAAMxB,UAAU,GAAG2B,UAAU,IAAIJ,QAAQ;MACzC,MAAMrB,OAAO,GAAGiB,YAAY,CAACvB,GAAG,CAACI,UAAU,CAAC,IAAI,IAAI;MAEpDtB,MAAM,CAACsB,UAAU,CAAC;MAElB8B,MAAM,GAAGhD,GAAG,CAACsC,OAAO,CAAC;QACnBY,aAAa,EAAE,KAAK;QAAE;QACtB,GAAGf,OAAO;QACVU,UAAU;QACVzB,OAAO;QACP0B,YAAY;QACZE,MAAM,EAAED,UAAU;QAAE;QACpBH,IAAI,EAAEA,IAAI,IAAI,GAAG;QACjBF,IAAI,EAAED;MACR,CAAC,CAAC;MAEFO,MAAM,CACHG,EAAE,CAAC,SAAS,EAAE,UAAU/B,OAAO,EAAE;QAChC;QACAiB,YAAY,CAAClB,GAAG,CAACD,UAAU,EAAEE,OAAO,CAAC;MACvC,CAAC,CAAC;IACN,CAAC,MAAM;MACLxB,MAAM,CAAC,CAACmD,UAAU,EAAE,2CAA2C,CAAC;MAChEC,MAAM,GAAGtD,GAAG,CAAC4C,OAAO,CAAC;QACnBY,aAAa,EAAE,EAAE,GAAG,IAAI;QAAE;QAC1B,GAAGf,OAAO;QACVW,YAAY;QACZF,IAAI,EAAEA,IAAI,IAAI,EAAE;QAChBF,IAAI,EAAED;MACR,CAAC,CAAC;IACJ;;IAEA;IACA,IAAIN,OAAO,CAACiB,SAAS,IAAI,IAAI,IAAIjB,OAAO,CAACiB,SAAS,EAAE;MAClD,MAAMC,qBAAqB,GAAGlB,OAAO,CAACkB,qBAAqB,KAAKtC,SAAS,GAAG,IAAI,GAAGoB,OAAO,CAACkB,qBAAqB;MAChHL,MAAM,CAACM,YAAY,CAAC,IAAI,EAAED,qBAAqB,CAAC;IAClD;IAEA,MAAME,aAAa,GAAGC,YAAY,CAAC,MAAMC,gBAAgB,CAACT,MAAM,CAAC,EAAEjB,OAAO,CAAC;IAE3EiB,MAAM,CACHU,UAAU,CAAC,IAAI,CAAC,CAChBC,IAAI,CAAChB,QAAQ,KAAK,QAAQ,GAAG,eAAe,GAAG,SAAS,EAAE,YAAY;MACrEY,aAAa,CAAC,CAAC;MAEf,IAAIf,QAAQ,EAAE;QACZ,MAAMoB,EAAE,GAAGpB,QAAQ;QACnBA,QAAQ,GAAG,IAAI;QACfoB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;MAChB;IACF,CAAC,CAAC,CACDT,EAAE,CAAC,OAAO,EAAE,UAAUU,GAAG,EAAE;MAC1BN,aAAa,CAAC,CAAC;MAEf,IAAIf,QAAQ,EAAE;QACZ,MAAMoB,EAAE,GAAGpB,QAAQ;QACnBA,QAAQ,GAAG,IAAI;QACfoB,EAAE,CAACC,GAAG,CAAC;MACT;IACF,CAAC,CAAC;IAEJ,OAAOb,MAAM;EACf,CAAC;AACH;AAEA,SAASQ,YAAYA,CAAEC,gBAAgB,EAAE1B,OAAO,EAAE;EAChD,IAAI,CAACA,OAAO,EAAE;IACZ,OAAO,MAAM,CAAC,CAAC;EACjB;EAEA,IAAI+B,EAAE,GAAG,IAAI;EACb,IAAIC,EAAE,GAAG,IAAI;EACb,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAM;IACjC;IACAH,EAAE,GAAGI,YAAY,CAAC,MAAM;MACtB,IAAIC,OAAO,CAACC,QAAQ,KAAK,OAAO,EAAE;QAChC;QACAL,EAAE,GAAGG,YAAY,CAAC,MAAMT,gBAAgB,CAAC,CAAC,CAAC;MAC7C,CAAC,MAAM;QACLA,gBAAgB,CAAC,CAAC;MACpB;IACF,CAAC,CAAC;EACJ,CAAC,EAAE1B,OAAO,CAAC;EACX,OAAO,MAAM;IACXsC,YAAY,CAACL,SAAS,CAAC;IACvBM,cAAc,CAACR,EAAE,CAAC;IAClBQ,cAAc,CAACP,EAAE,CAAC;EACpB,CAAC;AACH;AAEA,SAASN,gBAAgBA,CAAET,MAAM,EAAE;EACjCnD,IAAI,CAAC0E,OAAO,CAACvB,MAAM,EAAE,IAAIjD,mBAAmB,CAAC,CAAC,CAAC;AACjD;AAEAyE,MAAM,CAACC,OAAO,GAAG7C,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}