{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\nconst util = require('../core/util');\nconst {\n  kEnumerableProperty\n} = util;\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode\n} = require('./util');\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants');\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\nconst {\n  webidl\n} = require('./webidl');\nconst {\n  FormData\n} = require('./formdata');\nconst {\n  getGlobalOrigin\n} = require('./global');\nconst {\n  URLSerializer\n} = require('./dataURL');\nconst {\n  kHeadersList\n} = require('../core/symbols');\nconst assert = require('assert');\nconst {\n  types\n} = require('util');\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream;\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Response.json'\n    });\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init);\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(serializeJavascriptValueToJSONString(data));\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes);\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'response';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, {\n      body: body[0],\n      type: 'application/json'\n    });\n\n    // 5. Return responseObject.\n    return responseObject;\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect(url) {\n    let status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 302;\n    const relevantRealm = {\n      settingsObject: {}\n    };\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'Response.redirect'\n    });\n    url = webidl.converters.USVString(url);\n    status = webidl.converters['unsigned short'](status);\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL;\n    try {\n      parsedURL = new URL(url, getGlobalOrigin());\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code ' + status);\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status;\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL));\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value);\n\n    // 8. Return responseObject.\n    return responseObject;\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor() {\n    let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body);\n    }\n    init = webidl.converters.ResponseInit(init);\n\n    // TODO\n    this[kRealm] = {\n      settingsObject: {}\n    };\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({});\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm];\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null;\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body);\n      bodyWithType = {\n        body: extractedBody,\n        type\n      };\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType);\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type() {\n    webidl.brandCheck(this, Response);\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type;\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url() {\n    webidl.brandCheck(this, Response);\n    const urlList = this[kState].urlList;\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null;\n    if (url === null) {\n      return '';\n    }\n    return URLSerializer(url, true);\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected() {\n    webidl.brandCheck(this, Response);\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1;\n  }\n\n  // Returns response’s status.\n  get status() {\n    webidl.brandCheck(this, Response);\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status;\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok() {\n    webidl.brandCheck(this, Response);\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  }\n\n  // Returns response’s status message.\n  get statusText() {\n    webidl.brandCheck(this, Response);\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText;\n  }\n\n  // Returns response’s headers as Headers.\n  get headers() {\n    webidl.brandCheck(this, Response);\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders];\n  }\n  get body() {\n    webidl.brandCheck(this, Response);\n    return this[kState].body ? this[kState].body.stream : null;\n  }\n  get bodyUsed() {\n    webidl.brandCheck(this, Response);\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream);\n  }\n\n  // Returns a clone of response.\n  clone() {\n    webidl.brandCheck(this, Response);\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      });\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState]);\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n}\nmixinBody(Response);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n});\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n});\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({\n    ...response,\n    body: null\n  });\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body);\n  }\n\n  // 4. Return newResponse.\n  return newResponse;\n}\nfunction makeResponse(init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\nfunction makeNetworkError(reason) {\n  const isError = isErrorLike(reason);\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError ? reason : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  });\n}\nfunction makeFilteredResponse(response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  };\n  return new Proxy(response, {\n    get(target, p) {\n      return p in state ? state[p] : target[p];\n    },\n    set(target, p, value) {\n      assert(!(p in state));\n      target[p] = value;\n      return true;\n    }\n  });\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError(fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams));\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams) ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError')) : makeNetworkError('Request was cancelled.');\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse(response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.');\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText');\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status;\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText;\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers);\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code ' + response.status\n      });\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body;\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type);\n    }\n  }\n}\nwebidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);\nwebidl.converters.FormData = webidl.interfaceConverter(FormData);\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V);\n  }\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, {\n      strict: false\n    });\n  }\n  if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {\n    return webidl.converters.BufferSource(V);\n  }\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, {\n      strict: false\n    });\n  }\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V);\n  }\n  return webidl.converters.DOMString(V);\n};\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V);\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V;\n  }\n  return webidl.converters.XMLHttpRequestBodyInit(V);\n};\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([{\n  key: 'status',\n  converter: webidl.converters['unsigned short'],\n  defaultValue: 200\n}, {\n  key: 'statusText',\n  converter: webidl.converters.ByteString,\n  defaultValue: ''\n}, {\n  key: 'headers',\n  converter: webidl.converters.HeadersInit\n}]);\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse\n};","map":{"version":3,"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","isValidReasonPhrase","isCancelled","isAborted","isBlobLike","serializeJavascriptValueToJSONString","isErrorLike","isomorphicEncode","redirectStatus","nullBodyStatus","DOMException","kState","kHeaders","kGuard","kRealm","webidl","FormData","getGlobalOrigin","URLSerializer","kHeadersList","assert","types","ReadableStream","globalThis","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","json","data","arguments","length","undefined","init","argumentLengthCheck","header","converters","ResponseInit","bytes","TextEncoder","encode","body","initializeResponse","type","redirect","url","status","USVString","parsedURL","URL","err","Object","assign","TypeError","cause","includes","RangeError","value","append","constructor","BodyInit","makeResponse","bodyWithType","extractedBody","brandCheck","urlList","redirected","ok","statusText","headers","stream","bodyUsed","isDisturbed","clone","locked","errors","exception","message","clonedResponse","cloneResponse","clonedResponseObject","defineProperties","prototype","Symbol","toStringTag","configurable","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","requestIncludesCredentials","timingInfo","cacheState","reason","isError","Error","String","name","makeFilteredResponse","state","Proxy","get","target","p","set","freeze","makeAppropriateNetworkError","fetchParams","contains","interfaceConverter","URLSearchParams","XMLHttpRequestBodyInit","V","Blob","strict","isAnyArrayBuffer","isTypedArray","isDataView","BufferSource","isFormDataLike","DOMString","asyncIterator","dictionaryConverter","key","converter","defaultValue","ByteString","HeadersInit","module","exports"],"sources":["/Users/aluabajzanova/Desktop/skyline /node_modules/undici/lib/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode\n} = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  DOMException\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { webidl } = require('./webidl')\nconst { FormData } = require('./formdata')\nconst { getGlobalOrigin } = require('./global')\nconst { URLSerializer } = require('./dataURL')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\nconst { types } = require('util')\n\nconst ReadableStream = globalThis.ReadableStream || require('stream/web').ReadableStream\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data = undefined, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' })\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = new TextEncoder('utf-8').encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const relevantRealm = { settingsObject: {} }\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'response'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    const relevantRealm = { settingsObject: {} }\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' })\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, getGlobalOrigin())\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code ' + status)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError'))\n    : makeNetworkError('Request was cancelled.')\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: 'Invalid response status code ' + response.status\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {\n      response[kState].headersList.append('content-type', body.type)\n    }\n  }\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, { strict: false })\n  }\n\n  if (\n    types.isAnyArrayBuffer(V) ||\n    types.isTypedArray(V) ||\n    types.isDataView(V)\n  ) {\n    return webidl.converters.BufferSource(V)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}